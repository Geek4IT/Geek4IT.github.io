---
date: 2015-6-14 23:00:00+00:00
layout: post
title: 代码的未来(R)
thread: 48
categories: Reading
tags:  Reading
---

<img src="http://ec4.images-amazon.com/images/I/71TccQiaKmL._SL1287_.jpg" width="200" />

##[代码的未来](http://amzn.to/1RV4G44)

ISBN: 9787208105485 2015-6-14 RATING: */10

- 在这个世界上也有一些人，即便不去培养，他们也拥有想要编程的欲望，这样的人虽然只是小众，但他们会通过互联网获取丰富的知识，并不断攀登编程领域的高峰。

- 冷读术，就是通过观察对方言行举止中的一些细微之处来进行揣测的技巧。

- 要推测未来计算机的性能，最好的办法是看看现在的超级计算机。因为在超级计算机中为了实现高性能而采用的那些技术，其中一部分会根据摩尔定律变得越来越便宜，在 5 到 10 年后的将来，这些技术就会被用在主流 PC 中。

- 世界上最早的编程语言一般认为是 1954 年开始开发的 FORTRAN 语言。

- 从编程语言的进化过程来看，一个显著的关键词就是“抽象化”。抽象化就是提供一个抽象的概念，使用者即便不具备关于其内部详细情况的知识，也能够对其进行运用。由于不必了解其内部的情况，因此也被称为“黑箱化”。

- 能产生这样的生产效率差异，正是抽象化的力量。抽象度高的编程语言不必描述详细过程，从而可以用简短的代码达到目的。和抽象化程度的差异相比，变量名称、有没有指定数据类型之类的都只能算是误差级别的差异而已。

- 在未来，使用编程语言来编程这个行为本身不存在了。人类可以通过和计算机对话（大概是用自然语言）来查询和处理信息。（类似《星际迷航》中的世界，对于编程语言家来说是比较失落的未来）。

- 所谓 DSL，是指利用为特定领域（Domain）所专门设计的词汇和语法，简化程序设计过程，提高生产效率的技术，同时也让非编程领域专家的人直接描述逻辑成为可能。DSL的优点是，可以直接使用其对象领域中的概念，集中描述“想要做到什么”（What）的部分，而不必对“如何做到”（How）进行描述。

- 像以这些迷你语言为代表的，由专用的语言引擎来实现的 DSL，称为外部 DSL。UNIX 的迷你语言文化是先于 DSL 出现的，但并非只有 UNIX 才提供外部 DSL。和外部 DSL 相对的自然就是内部 DSL 了。外部 DSL 是从 UNIX 中脱胎发展而来的，而内部 DSL 则是发源于 Lisp 和 Smalltalk 的文化之中。

- 内部 DSL 并不是创造一种新的语言，而是在现有语言中实现 DSL，而作为 DSL基础的这种现有语言，称为宿主语言。什么样的语言适合用作内部 DSL 的宿主语言呢？虽然任何语言都可以成为宿主语言，但像 Lisp、Smalltalk、Ruby 这样被认为适合 DSL 的语言，都拥有一些共同的特征。首先是简洁。由于 DSL 本来就是为了将针对特定目的处理用高级的、简洁的方式进行描述，因此简洁的描述方式才是最本质的。从这个意义上来讲，语言简洁是作为 DSL 宿主语言不可或缺的要素。Lisp 和 Ruby 等语言中，无需在程序中声明数据类型，编译器的“规矩”也比较少，因此能够让程序变得简洁。作为宿主语言的另一个重要特征就是灵活性。

- 不过，无论内存容量有多大，总归不是无限的。实际上，伴随着内存容量的增加，软件的内存开销也在以同样的速率增加着。因此，最近的计算机系统会通过“双重”幻觉，让我们以为内存容量是无限的。 第一重幻觉是垃圾回收（GC）机制。第二重幻觉是操作系统提供的虚拟内存。由于硬盘的容量要远远大于内存（RAM），虚拟内存正是利用这一点，在内存容量不足时将不经常被访问的内存空间中的数据写入硬盘，以增加“账面上”可用内存容量的手段。现在，虽说内存容量已经增加了很多，但也不过是区区几个 GB 而已。相对的，即便是笔记本电脑上的硬盘，也已经有几百 GB 的容量，超过 1TB（1000GB）的也开始出现了。虚拟内存也就是利用了这样的容量差异。 书桌上的文件摊满了，也就没地方放新的文件了。所谓虚拟内存，就好比是将书桌上比较老的文件先暂时收到抽屉里，用空出来的地方来摊开新的文件。 

- 在 Java 和 Ruby 这样的语言中，程序在运行时会创建很多对象。从编程语言的角度来看，它们是对象；但从计算机的角度来看，它们也就是一些装有数据的内存空间而已。

- 所谓垃圾（Garbage），就是需要回收的对象。作为编写程序的人，是可以做出“这个对象已经不再需要了”这样的判断，但计算机是做不到的。因此，如果程序（通过某个变量等等）可能会直接或间接地引用一个对象，那么这个对象就被视为“存活”；与之相反，已经引用不到的对象被视为“死亡”。将这些“死亡”对象找出来，然后作为垃圾进行回收，这就是 GC 的本质。

- 引用计数最大的缺点，就是无法释放循环引用的对象。第二个缺点，就是必须在引用发生增减时对引用计数做出正确的增减，而如果漏掉了某个增减的话，就会引发很难找到原因的内存错误。引用数忘了增加的话，会对不恰当的对象进行释放；而引用数忘了减少的话，对象会一直残留在内存中，从而导致内存泄漏。最后一个缺点就是，引用计数管理并不适合并行处理。如果多个线程同时对引用计数进行增减的话，引用计数的值就可能会产生不一致的问题（结果则会导致内存错误）。


- 分代回收的基本思路，是利用了一般性程序所具备的性质，即大部分对象都会在短时间内成为垃圾，而经过一定时间依然存活的对象往往拥有较长的寿命。如果寿命长的对象更容易存活下来，寿命短的对象则会被很快废弃，那么到底怎样做才能让 GC 变得更加高效呢？如果对分配不久，诞生时间较短的“年轻”对象进行重点扫描，应该就可以更有效地回收大部分垃圾。





